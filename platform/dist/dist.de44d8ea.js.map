{"version":3,"sources":["index.mjs","models.mjs","Vector.mjs","DOMDisplay.mjs","State.mjs","actors/Lava.mjs","actors/Player.mjs","actors/Coin.mjs","Level.mjs"],"names":["PLAYER","LAVA","COIN","class","actors","constructor","reset","style","other","pos","Coin","element","Player","factor","ACTORS","attributes","children","LAVA_STATIC","keys","char","down","event","basePos","createRows","Lava","Vector","isActor","prototype","level","tempRows","yPosition","ArrowLeft","top","xSpeed","ArrowRight","type","startActors","State","movedX","touches","newPos","actor","wobblePos","state","sin","wobbleDist","movedY","plus","time","parent","ySpeed","dom","syncState","className","scrollPlayerIntoView","status","Math","size","x","scrollTop","bottom","left","length","scrollLeft","console","log","center","y"],"mappings":";;;;AAAA;;AACA;;ACDO;AACLA,aCDkB,GAAA,UDAE,OCAF,EDAE,KCAF,EDAE,KCAF,EDAE,UCAF,EDAE;AAEpBC;AACAC,MAAI,eECF,GADY,OAEZ,aAFY,KAEZ,UAFY,IAEZ,aFFFA;AAHK,MEMDC,WCHF,GAAcC,OAAd,OAAcA,KAAd,UAAcA,IAAd,OHHG;;AIILC,WJEgB,UIFhBA,CFKK,IELLA,EAAwBC,MAAxBD,EAA+B;AFQvBE,QDNHC,CGDEC,KHCK,CIDC,IJCD,CCMJF,EFNW;AMARG,UAAN,CLCI,ODCM,CAAA,IAAA,CMFJA,EJOcC;AGNdC;AHJX;ADOMC;ADEA,YGDN,cIJe,GNIK,OMLF,aNKE,KAAX,UAAW,IAAlB,aDCI;;AACA,YIFGC,CJLU,MIKVA,IFQYC,cFNf,EEM8BC;AHH5B,iBQPDC,cAAc,CROrB,IQPqB,EAHH,IAGG,CROb;AGKDC,SARkBP,CEEnBQ;ALIFC;AACAC;AOFEC;;;AFDG,YEEA,eFFA,EEEkBA;ACFpBC,iBHGQC,eAAcC,CAAAA,IAAAA,EAAAA,IAAAA,CGHtBF;ALYAZ,SAhBkBA,CKMnBe;;;AFGDC,YAAAA,WAAP,IFK2B,OAAKC,IAAL,KELQ,QAA5BD,EAAP;AEFSE,iBAAQ,WAAWC,CAAAA,IAAAA,CAAnBD;ALeEtB;;AAED,YGXCwB,GHWMC,GAAX,IGXgBC,KHWhB,CGXsB,0BCA1B,IDA0B,GFI+B,IDOrD,CAAI;AGVJf,QAAAA,GAAKgB,CCAC,IDANhB,GEJYiB,kBFIZjB;AEHEkB,cHIKC,GGJLD;AFKFE;;AACA,MAAA,YAAC,CAAYC,OAAb,GNIe,OMJf;ADEAC,MAAAA,YDGWC,CJAE,KKHbD,GFYO,EEZPA;AEEAE,UFDCC,MECQ,GFDIJ,KECIK,CAAAA,IAAAA,CFDJL,GECD,IAAmBM,UAAnC,CAAA,MAAgB,CFDqC,IECrC,CAAZH;ADAAI,MAAAA,ODCO,CAAA,IAAA,CCDPA,CAAaC,CAAbD,EAAS,IAATA,CAAsBrB,MNIxB,CAAA,OMJEqB,EAAkB,YAAlBA,EAAyCE,MAAzCF,EAAJ,MAAA,CAAA,OAAIA,EAAJ,IAAIA;AHaFG;;AGXAxC,WDEO,KCFP,CAAA,IAAA,CDEO,CLEY,OMJnBA;;AAEAyC,aAAS,YAATA,CAAA,CAAAA,EAAA;AADK,aEII,UREb,CAAA,YAAkC,CAAA,OAAlC,CAAkC,CAAlC,CAAA,CMNS;AAGLA;;AEIA,aRCO,OQDP,CAAarB,CAAb,EAAaA;AFFf,aAAWjB,OAAOH,CAAAA,IAAAA,CAAPG,CAAY,CAAZA,EAAgBa,CAAhBb,KAAgBa,CAA3B;AAlBF;AEwBG;;AARgB,WRSR,MQTQ,CLiBjB,UKjBiB,ELiBW;AAC5B,SAAK0B,EAAL,GHRYC,UGQZ;AACA,SAAKD,MAAL,GAASE,UAAT;AACA,SAAKC,OAAL,GHTcC,EGSd;AALF;;AKFE,EAAA,ULUS5B,CKVE6B,eAAX,GAA6BC,IAA7B;AACA,EAAA,UAAU,CAAA,MAAV,GLUY,MKVZ;AACA,EAAA,ULUU,CKVCD,OAAX,GAAqB/C,OAArB;ALWA,EAAA,UAAU,CAAA,KAAV,GHTM,KGSN;AKVA,EAAA,UAAU,CAAA,MAAV,GREoB8C,eQFpB;;AACE,EAAA,ULWM,CKXGG,QAAT,GAAA,UAAA,EAAA,EAAA,OAAA,EAAoC;AAClC,IAAA,OLWG,CAAA,EAAA,CKXH,GLWU,CKXG,UAAG,OAAH,EAAiB,MAAjB,EAAG;ALYhB1B,MAAAA,MAAM,CAAA,OAANA,GAAe2B,OAAf3B;AHvBJ,KGsBc,EAEZ4B,EAFY,CKXV;AAGD,GAJD;;ARQJ,MAAA,KAAA;;AQFE,ORGK,IAAIhC,CGQC,GKXV,CAAA,ELWeiC,CHRE,GAAGjC,KAAK,CAAA,MQHzB,ERGkCkC,CAAAA,EQHlC,ERGkCA;AQfpC,QRgBQP;AGON,MAAA,UHNY,CAAA,KGQD,CHRT,CGQS,CHRC,CGMZ;AAGE,KK1BJ,CL0BI,OAASQ,CAAT,EAASA;AACV;AHRDC,UAAQC,CAAAA,KAARD,EAAY;AGSRE,QAAAA,KAAOC,GAAP,CAAAD;AACF;AADF;AAGE;;AAnBJ,MAAA,KAAA,CAAA,MAAA,EAAA;;;0DAAA;;;;;;;;;;;GF/DsB;;;;;;;;;;;CCAF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA,IAAA,6EAAA,MAAA,CDClBlE","file":"dist.de44d8ea.js","sourceRoot":"..","sourcesContent":["import { Level } from \"./Level.mjs\";\nimport { DOMDisplay } from \"./DOMDisplay.mjs\";\nimport { State } from \"./State.mjs\";\n\nlet simpleLevelPlan = `\n......................\n..#................#..\n..#..............=.#..\n..#.........o.o....#..\n..#.@......#####...#..\n..#####............#..\n......#++++++++++++#..\n......##############..\n......................`;\n\nfunction trackKeys(keys) {\n  let down = Object.create(null);\n  function track(event) {\n    if (keys.includes(event.key)) {\n      down[event.key] = event.type == \"keydown\";\n      event.preventDefault();\n    }\n  }\n  window.addEventListener(\"keydown\", track);\n  window.addEventListener(\"keyup\", track);\n  return down;\n}\n\nconst arrowKeys = trackKeys([\"ArrowLeft\", \"ArrowRight\", \"ArrowUp\"]);\n\nfunction runAnimation(frameFunc) {\n  let lastTime = null;\n  function frame(time) {\n    if (lastTime != null) {\n      let timeStep = Math.min(time - lastTime, 100) / 1000;\n      if (frameFunc(timeStep) === false) return;\n    }\n    lastTime = time;\n    requestAnimationFrame(frame);\n  }\n  requestAnimationFrame(frame);\n}\n\nfunction runLevel(level, Display) {\n  let display = new Display(document.body, level);\n  let state = State.start(level);\n  let ending = 1;\n  return new Promise(resolve => {\n    runAnimation(time => {\n      state = state.update(time, arrowKeys);\n      display.syncState(state);\n      if (state.status == \"playing\") {\n        return true;\n      } else if (ending > 0) {\n        ending -= time;\n        return true;\n      } else {\n        display.clear();\n        resolve(state.status);\n        return false;\n      }\n    });\n  });\n}\n\nasync function runGame(plans, Display) {\n  for (let level = 0; level < plans.length; ) {\n    let status = await runLevel(new Level(plans[level]), Display);\n    if (status == \"won\") level++;\n  }\n  console.log(\"You've won!\");\n}\n\nrunGame([simpleLevelPlan], DOMDisplay).then(_ => console.log(\"end\"));\n","export const ACTORS = {\n  PLAYER: \"player\",\n  LAVA: \"lava\",\n  COIN: \"coin\"\n};\n\nexport const CHARS = {\n  LAVA_HORIZONTAL: \"=\",\n  LAVA_VERTICAL: \"|\",\n  LAVA_DRIPPING: \"v\",\n  LAVA_STATIC: \"+\",\n  EMPTY: \".\",\n  WALL: \"#\",\n  PLAYER: \"@\",\n  COIN: \"o\"\n};\n","export class Vector {\n  constructor(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  plus(other) {\n    return new Vector(this.x + other.x, this.y + other.y);\n  }\n\n  times(factor) {\n    return new Vector(this.x * factor, this.y * factor);\n  }\n}\n","const scale = 20;\n\nfunction drawGrid(level) {\n  return element(\n    \"table\",\n    {\n      class: \"background\",\n      style: `width: ${level.width * scale}px`\n    },\n    ...level.rows.map(row =>\n      element(\n        \"tr\",\n        { style: `height: ${scale}px` },\n        ...row.map(type => element(\"td\", { class: type }))\n      )\n    )\n  );\n}\n\nfunction element(name, attributes, ...children) {\n  const newElement = document.createElement(name);\n  Object.keys(attributes).forEach(attribute => {\n    newElement.setAttribute(attribute, attributes[attribute]);\n  });\n  children.forEach(child => newElement.appendChild(child));\n  return newElement;\n}\n\nfunction drawActors(actors) {\n  return element(\n    \"div\",\n    {},\n    ...actors.map(actor => {\n      let rect = element(\"div\", { class: `actor ${actor.type}` });\n      rect.style.width = `${actor.size.x * scale}px`;\n      rect.style.height = `${actor.size.y * scale}px`;\n      rect.style.left = `${actor.pos.x * scale}px`;\n      rect.style.top = `${actor.pos.y * scale}px`;\n      return rect;\n    })\n  );\n}\n\nexport class DOMDisplay {\n  constructor(parent, level) {\n    this.dom = element(\"div\", { class: \"game\" }, drawGrid(level));\n    this.actorLayer = null;\n    parent.appendChild(this.dom);\n  }\n\n  clear() {\n    this.dom.remove();\n  }\n}\n\nDOMDisplay.prototype.syncState = function(state) {\n  if (this.actorLayer) this.actorLayer.remove();\n  this.actorLayer = drawActors(state.actors);\n  this.dom.appendChild(this.actorLayer);\n  this.dom.className = `game ${state.status}`;\n  this.scrollPlayerIntoView(state);\n};\n\nDOMDisplay.prototype.scrollPlayerIntoView = function(state) {\n  let width = this.dom.clientWidth;\n  let height = this.dom.clientHeight;\n  let margin = width / 3;\n  // The viewport\n  let left = this.dom.scrollLeft,\n    right = left + width;\n  let top = this.dom.scrollTop,\n    bottom = top + height;\n  let player = state.player;\n  let center = player.pos.plus(player.size.times(0.5)).times(scale);\n  if (center.x < left + margin) {\n    this.dom.scrollLeft = center.x - margin;\n  } else if (center.x > right - margin) {\n    this.dom.scrollLeft = center.x + margin - width;\n  }\n  if (center.y < top + margin) {\n    this.dom.scrollTop = center.y - margin;\n  } else if (center.y > bottom - margin) {\n    this.dom.scrollTop = center.y + margin - height;\n  }\n};\n","export class State {\n  constructor(level, actors, status) {\n    this.level = level;\n    this.actors = actors;\n    this.status = status;\n  }\n\n  static start(level) {\n    return new State(level, level.startActors, \"playing\");\n  }\n\n  get player() {\n    return this.actors.find(actor => actor.type == \"player\");\n  }\n}\n\nfunction overlap(actor1, actor2) {\n  return (\n    actor1.pos.x + actor1.size.x > actor2.pos.x &&\n    actor1.pos.x < actor2.pos.x + actor2.size.x &&\n    actor1.pos.y + actor1.size.y > actor2.pos.y &&\n    actor1.pos.y < actor2.pos.y + actor2.size.y\n  );\n}\n\nState.prototype.update = function(time, keys) {\n  let actors = this.actors.map(actor => actor.update(time, this, keys));\n  let newState = new State(this.level, actors, this.status);\n  if (newState.status != \"playing\") return newState;\n  let player = newState.player;\n  if (this.level.touches(player.pos, player.size, \"lava\")) {\n    return new State(this.level, actors, \"lost\");\n  }\n  for (let actor of actors) {\n    if (actor != player && overlap(actor, player)) {\n      newState = actor.collide(newState);\n    }\n  }\n  return newState;\n};\n","import { ACTORS, CHARS } from \"../models.mjs\";\nimport { Vector } from \"../Vector.mjs\";\n\nexport class Lava {\n  constructor(pos, speed, reset) {\n    this.pos = pos;\n    this.speed = speed;\n    this.reset = reset;\n  }\n\n  get type() {\n    return ACTORS.LAVA;\n  }\n\n  static create(pos, char) {\n    if (char == CHARS.LAVA_HORIZONTAL) {\n      return new Lava(pos, new Vector(2, 0));\n    } else if (char == CHARS.LAVA_VERTICAL) {\n      return new Lava(pos, new Vector(0, 2));\n    } else if (char == CHARS.LAVA_DRIPPING) {\n      return new Lava(pos, new Vector(0, 3), pos);\n    }\n  }\n}\n\nLava.prototype.size = new Vector(1, 1);\n\nLava.prototype.collide = function(state) {\n  return new State(state.level, state.actors, \"lost\");\n};\n\nLava.prototype.update = function(time, state) {\n  let newPos = this.pos.plus(this.speed.times(time));\n  if (!state.level.touches(newPos, this.size, \"wall\")) {\n    return new Lava(newPos, this.speed, this.reset);\n  } else if (this.reset) {\n    return new Lava(this.reset, this.speed, this.reset);\n  } else {\n    return new Lava(this.pos, this.speed.times(-1));\n  }\n};\n","import { ACTORS } from \"../models.mjs\";\nimport { Vector } from \"../Vector.mjs\";\n\nconst playerXSpeed = 7;\nconst gravity = 30;\nconst jumpSpeed = 17;\n\nexport class Player {\n  constructor(pos, speed) {\n    this.pos = pos;\n    this.speed = speed;\n  }\n\n  get type() {\n    return ACTORS.PLAYER;\n  }\n\n  static create(pos) {\n    return new Player(pos.plus(new Vector(0, -0.5)), new Vector(0, 0));\n  }\n}\n\nPlayer.prototype.size = new Vector(0.8, 1.5);\n\nPlayer.prototype.update = function(time, state, keys) {\n  let xSpeed = 0;\n  if (keys.ArrowLeft) xSpeed -= playerXSpeed;\n  if (keys.ArrowRight) xSpeed += playerXSpeed;\n  let pos = this.pos;\n  let movedX = pos.plus(new Vector(xSpeed * time, 0));\n  if (!state.level.touches(movedX, this.size, \"wall\")) {\n    pos = movedX;\n  }\n  let ySpeed = this.speed.y + time * gravity;\n  let movedY = pos.plus(new Vector(0, ySpeed * time));\n  if (!state.level.touches(movedY, this.size, \"wall\")) {\n    pos = movedY;\n  } else if (keys.ArrowUp && ySpeed > 0) {\n    ySpeed = -jumpSpeed;\n  } else {\n    ySpeed = 0;\n  }\n  return new Player(pos, new Vector(xSpeed, ySpeed));\n};\n","import { ACTORS } from \"../models.mjs\";\nimport { Vector } from \"../Vector.mjs\";\n\nconst wobbleSpeed = 8,\n  wobbleDist = 0.07;\n\nexport class Coin {\n  constructor(pos, basePos, wobble) {\n    this.pos = pos;\n    this.basePos = basePos;\n    this.wobble = wobble;\n  }\n\n  get type() {\n    return ACTORS.COIN;\n  }\n\n  static create(pos) {\n    let basePos = pos.plus(new Vector(0.2, 0.1));\n    return new Coin(basePos, basePos, Math.random() * Math.PI * 2);\n  }\n}\n\nCoin.prototype.size = new Vector(0.6, 0.6);\n\nCoin.prototype.collide = function(state) {\n  let filtered = state.actors.filter(a => a != this);\n  let status = state.status;\n  if (!filtered.some(a => a.type == \"coin\")) status = \"won\";\n  return new State(state.level, filtered, status);\n};\n\nCoin.prototype.update = function(time) {\n  let wobble = this.wobble + time * wobbleSpeed;\n  let wobblePos = Math.sin(wobble) * wobbleDist;\n  return new Coin(\n    this.basePos.plus(new Vector(0, wobblePos)),\n    this.basePos,\n    wobble\n  );\n};\n","import { CHARS } from \"./models.mjs\";\nimport { Player } from \"./actors/Player.mjs\";\nimport { Coin } from \"./actors/Coin.mjs\";\nimport { Lava } from \"./actors/Lava.mjs\";\nimport { Vector } from \"./Vector.mjs\";\n\nconst LEVEL_CHARS = {\n  [CHARS.EMPTY]: \"empty\",\n  [CHARS.WALL]: \"wall\",\n  [CHARS.LAVA_STATIC]: \"lava\",\n  [CHARS.PLAYER]: Player,\n  [CHARS.COIN]: Coin,\n  [CHARS.LAVA_HORIZONTAL]: Lava,\n  [CHARS.LAVA_VERTICAL]: Lava,\n  [CHARS.LAVA_DRIPPING]: Lava\n};\n\nfunction createRows(tempRows, startActors) {\n  const getType = char => LEVEL_CHARS[char];\n  const isActor = type => typeof type != \"string\";\n  return tempRows.map((row, yPosition) => {\n    return row.map((char, xPosition) => {\n      const type = getType(char);\n      if (isActor(type)) {\n        startActors.push(type.create(new Vector(xPosition, yPosition), char));\n        return \"empty\";\n      } else {\n        return type;\n      }\n    });\n  });\n}\n\nfunction getTempRows(plan) {\n  return plan\n    .trim()\n    .split(\"\\n\")\n    .map(l => [...l]);\n}\n\nexport class Level {\n  constructor(plan) {\n    let tempRows = getTempRows(plan);\n    this.height = tempRows.length;\n    this.width = tempRows[0].length;\n    this.startActors = [];\n\n    this.rows = createRows(tempRows, this.startActors);\n  }\n}\n\nLevel.prototype.touches = function(pos, size, type) {\n  var xStart = Math.floor(pos.x);\n  var xEnd = Math.ceil(pos.x + size.x);\n  var yStart = Math.floor(pos.y);\n  var yEnd = Math.ceil(pos.y + size.y);\n  for (var y = yStart; y < yEnd; y++) {\n    for (var x = xStart; x < xEnd; x++) {\n      let isOutside = x < 0 || x >= this.width || y < 0 || y >= this.height;\n      let here = isOutside ? \"wall\" : this.rows[y][x];\n      if (here == type) return true;\n    }\n  }\n  return false;\n};\n"]}